### zstack 4.0

随着 ZStack 4.0 的正式发布，相信不少同行已经有了比较直观的视觉体验，本轮升级不是一次简单的重构，而是完全的重写，底层技术栈从 Vue 成功替换为 React，我们为什么要推翻一个已经稳定成熟的产品，冒着巨大的风险去做一个全新版本呢？

在正式讨论 4.0 的架构细节之前，先简单回顾下开发 3.x 遇到的几个问题。

1. 3.x 从 17年正式发布到20年历时三年，供经历过 14 个大版本迭代，从第一个版本开始，底层架构上都没有太多变化，负责构建的 webpack 一直引用的 1.4 版本，当代码膨胀到 50 万行时，每次启动项目都要花费 约 6分钟时间，无效等待严重影响开发人员的工作效率和幸福感。
2. 代码缺少分层，没有全局状态管理，不同组件通信没有通过消息解耦，而是函数间调用，其中还有循环依赖的问题，代码重构无从下手。
3. 缺乏组件化，代码重复率非常高，云主机列表在很多地方都会出现，实际实现时都是 copy/paste 原有代码，代码冗余造成了全局变更某些功能异常困难，比如给云主机增加标签功能，需要按照关键词查找所有依赖，频繁的变动也会给测试人员带来困扰。

随着公司业务快速发展，原来的 UI 架构已经无法支撑不断变化的需求，前端团队也面临人员流失等问题，与其在一栋危楼上修修补补，不如拆除重建，于是 4.0 应运而生。在正式搭建架构之前，架构组进行了大量调研，先以云主机为基础，搭建基座，再扩展到所有模块，现将实际开发中遇到的问题和经验分享给大家，分为前端工程化、组件化、强类型、GraphQL、状态管理、微前端和低代码实现7个篇幅。

#### 前端工程化

在正式开发之前，需要先搭建脚手架，无论是 Vue 还是 React，社区都有非常多成熟的解决方案，我们在构建 4.0 时选用了蚂蚁金服体验技术部开源的 umi [https://umijs.org/](https://umijs.org/)，umi 集成了 React 企业级应用开发所需的大部分依赖，默认的 webpack 配置可以非常方便的支持 Less、CSS Module、TypeScript 等主流前端技术，同时完美集成著名开源组件库 antd，微前端框架 qiankun。

在具体实践上，我们针对 umi 进行了二次封装，可以让开发人员以非常简单的方式，10行代码不到快速搭建一个微应用，利用 umi 的插件系统，我们重写了 i18n、sourcemap 等插件，使之能完美适配微前端架构。
![https://github.com/mango-lzp/notes/blob/main/img/%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8.png?raw=true](https://github.com/mango-lzp/notes/blob/main/img/%E6%96%87%E4%BB%B6%E5%88%97%E8%A1%A8.png?raw=true)

#### 组件化

在升级 4.0 之后，大家会发现界面焕然一新，交互方式也更为多样，以云主机创建为例，不仅有多步创建，还有快捷创建，创建页面利用了大量基础组件，如输入框、开关按钮、下拉框、抽屉、标签页等，更为有趣的是，整个创建页也是一个大组件，封装了步骤条、数据收集、校验等功能，同时云主机的创建页还用在了引导页、工单、资源编排等页面。

良好的架构一定是用最少的代码去支撑尽可能多的功能，在正式开发业务代码之前，架构团队和设计团队耗时两个月针对几类常见页面，列表、表格、详情页、图表页的共同特征，抽象出 24 个常用组件，为了在一开始就能支持多主题切换，对于色彩和图标上也进行了深度封装。
![https://github.com/mango-lzp/notes/blob/main/img/4.0UI%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6.png?raw=true](https://github.com/mango-lzp/notes/blob/main/img/4.0UI%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6.png?raw=true)

#### 强类型

JavaScript 是一门弱类型语言，编辑器无法进行类型推断，如果编写的代码引用了错误的对象，VSCode 并不会提示，这给开发测试人员带来了很大的困扰，一个严重的页面白屏 bug 有可能只是因为大小写拼写错误导致的空引用。

ZStack 后端用 Java 编写，是面向对象的强类型语言，在领域模型中，后端的数据传输到前端展现，需要经过BO→VO 的转换，抛去语言差异、通信协议，前端页面无非是后端数据的投影，如果能把后端类型定义解析为 TypeScript 形式供前端调用，就可以规避大部分空指针问题。我们在具体实践中，采用 Node 以正则解析的方式针对后端定义的POJO、Enum 类型做了自动追踪转换，生成 TS SDK，同时无论组件还是业务代码都全部采用 TypeScript 编码，有了智能提示加持，不仅大大提高了编码速度，还顺带解决了空引用问题。

#### GraphQL

ZStack API 为了便于扩展，只暴露了一些非常基础的 API，而真实的用户场景往往千变万化，比如云主机主列表页面，管理员除了想查看云主机基本信息外，还想看这台云主机在哪个集群，哪台物理机，绑定哪些三层网络和安全组，甚至还希望cpu 负载、内存占用这些实时数据也能在一个界面展示。对后端来说，这些信息在数据库是以多张关联表的形式存在，后端在暴露 API 时出于性能考虑很少会做关联查询，如果想满足上述需求，前端就需要调用 N 个 API 进行组合映射，当 API 调用超过三个时，代码写起来非常臃肿也难以扩展。

经过一段时间的调研，觉得 GraphQL 这样的图查询协议能够以较低的成本解决级联查询问题，为了把 ZStack Rest API 调用转换为 GraphQL，我们用 Node 编写了一个中间层，采用 nestjs 作为基础架构，并集成 Apollo，级联查询封装可以用 query 轻易实现，而操作涉及异步调用，需要结合 mutation、subscription 和 webhook 以 websocket 的方式把执行结果发送给前端，关于 GraphQL 查询常见的 n+1 问题， 选用 data-loader 进行解决，把同类资源的多个单一查询转换为 in 查询，来降低数据库的读取压力。

#### 状态管理

Redux 是 React 生态体系中非常有名的库，采用命令模式进行中心化状态管理，Redux 自身也因为良好的扩展性，社区提出了许多非常棒的解决方案，如 Redux-Saga、React-Redux、Dva 等，Redux 虽然成熟，但也有先天不足，对 TypeScript 支持不强，特别是做大型项目开发，负责修改数据的 Reducer 入参出参都需要定义类型，成本很高。

我们在本次编写 React 组件时，并没有采用传统的基于 Components 的构建方式，而是尝试了全新 API，React Hooks。 Hooks 没有 Components 复杂的生命周期管理，而是暴露了几个非常简单的 API，useState 负责持有私有状态，实现数据到视图的单向绑定，useEffect 负责处理副作用，监听状态变更封装异步逻辑，useContext 可以访问全局状态，进行跨组件通信，Redux 通过编排指令来实现复杂的业务逻辑，而 Hooks 则是采用监听的方式，在调用链上两者相反。

Hooks 的隔离性可以非常方便的进行逻辑复用，以云主机举例，云主机的主列表、挂在其他资源下的子列表以及创建操作时展开的选择列表，其实都是用的同一段代码逻辑，通过传不同的参数来进行控制，这样做的好处是子列表和选择列表也可以利用主列表已经完成的复杂逻辑，比如搜索、过滤、排序等功能。

状态修改触发页面变更，在 Redux 中称之为 Mutation，如果涉及异步，还会有副作用 Effect，Redux 自身没有解决 Effect，而是通过中间件，如 Saga 等处理异步，Saga 的编写异常复杂，也缺乏固定的范式，再后来诞生了 Dva 对 Saga 再次封装，这些开源库都是为了让开发人员在处理复杂工作流时能得心应手，但是否有更简单优雅的方案呢？

答案是肯定的，正如上文提到我们在通信层采用了 GraphQL，GraphQL 同样是一门强类型语言，自身的 Schema 特性和 Dva 中的 model 层异曲同工，由于我们所有的数据获取及变更都是通过调用 Apollo Client API 来实现，而 Apollo 在发起 GraphQL 请求后会按照 Schema 定义把数据缓存起来，这种机制称之为 Apollo Cache，类似 Redux 的 Store，Cache 也是全局的，有了前面的基础，自然而然就可以想到，mutation 完全可以通过直接修改 Apollo Cache 来实现，伪代码如下所示:
`apollo.writeFragment({`

`id: apollo.cache.identify({`

`__typename: type,`

`uuid`

`}),`

`fragment: gql``

`fragment ${type}Fragment on ${type} {`

`${fields}`

`}`

``,`

`data: inventory,`

`broadcast: **false**` `// 只更新需要修改的字段,其余字段不通过fetchPolicy更新`

`})`

跨组件的状态更新，如启动云主机时，除了列表状态发生变化，云主机的运行数量也需要变化，同样也可以通过改写 Apollo Cache 来实现。

#### 微前端

当代码量达到 10 万行以上时，单纯的采用远程开发，增加机器内存已经很难提升编译速度，解决一个复杂问题，最好的办法是分治，把问题切割成若干小份进行解决，而微前端就是目前业界最流行的超大项目解决方案。微前端只是一个概念，在具体实现上可以采用多页、IFrame、单页等，多页和 IFrame 在加载不同应用时都会造成页面刷新卡顿，用户体验不好，为了追求极致的用户体验，只能采用 Single-SPA 的方式。Single-SPA 和基于 React 的 SPA 不同点在于多了一层路由拦截，即先拦截第一层去加载不同的应用，当应用加载完毕后再利用 React-Router 等加载具体的页面。在前文中提到了 4.0 采用了基于 Single-SPA 的企业级微前端框架 Qiankun，笔者是 Qiankun 最早的开发和维护者，Qiankun 在 Single-SPA 的基础上增加了两个核心功能，import-html-entry 和 sandbox，前者用于子应用构建产物 html、js、css 的加载，后者则是利用 Proxy 做主子应用以及应用间的状态隔离。Qiankun 目前仍在迭代，没有一定源码修改功底建议不要尝试。
![https://github.com/mango-lzp/notes/blob/main/img/%E6%9E%B6%E6%9E%84%E5%9B%BE%E8%A7%A3.png?raw=true](https://github.com/mango-lzp/notes/blob/main/img/%E6%9E%B6%E6%9E%84%E5%9B%BE%E8%A7%A3.png?raw=true)

#### 低代码
随着项目的顺利进行，代码编写速度在不断加快，不过一些问题也暴露出来，由于开发人员的水平差异，编写的页面，特别是列表页缺乏统一的规范，列宽定义随意，常量没有做很好的转换，用的颜色、图标不对，表格应该展现哪些列、顺序如何定义并没有一个权威的信息源。类似这样的问题还有一个页面应该放哪些按钮、这些按钮在什么权限下展示、界面的文字如果是多语言如何编辑、多主题时色彩如何定义，这些问题很难用文字来表述清楚，同时不同团队角色对问题的理解也缺乏一致，单单一个按钮放在什么位置，在什么权限下显示，显示文字是什么样，交互形式又如何，就涉及到 PM、设计师、文档、测试等多个团队，最后还需要开发人员进行编码解决，如果没有一个很好的沟通方式，势必陷入前期混战，后期扯皮的不利境况，这样开发人员就会在非技术问题上浪费大量时间。

为了解决跨前端协作的问题，我们采用了两种方式解决，钉钉配置表和配置系统，钉钉的 Excel 表是一个很好的多人协作平台，我们只需要约定一个资源所有的展现形式，就可以根据配置表自动生成代码，如下图所示。
![https://github.com/mango-lzp/notes/blob/main/img/%E4%BD%8E%E4%BB%A3%E7%A0%81excel.png?raw=true](https://github.com/mango-lzp/notes/blob/main/img/%E4%BD%8E%E4%BB%A3%E7%A0%81excel.png?raw=true)

而配置系统一开始是为了解决界面文字的国际化问题，后来发现权限控制等也可以采用配置系统解决。我们创新性的在 UI 界面上增加了一个 Debug 模式，当开启 Debug 时，会标记页面中所有可以进行权限控制的元素，鼠标悬浮上去就可以跳转到配置系统供 PM 和 测试人员进行配置。

![https://github.com/mango-lzp/notes/blob/main/img/debug%E6%A8%A1%E5%BC%8F.png?raw=true](https://github.com/mango-lzp/notes/blob/main/img/debug%E6%A8%A1%E5%BC%8F.png?raw=true)
而针对国际化，我们用 Babel AST 解析代码中所有的 formatMessage 标记，将初始 key 和默认中文导入 i18n 系统，最后再由翻译人员进行完善，翻译完毕后再通过 CI 系统拉取并进行打包。

![https://github.com/mango-lzp/notes/blob/main/img/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F.png?raw=true](https://github.com/mango-lzp/notes/blob/main/img/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F.png?raw=true)

目前自动生成的代码约为 1**5万行**，占整个 UI 代码的 1/4，却完成了界面中所有的列表、按钮显示，权限控制、主题切换、多语言切换等功能，这些是各团队共同协作的结晶。

以上便是 ZStack 4.0 架构的所有秘密，感谢您的阅读，今年前端团队的重点是自动化测试，届时也会有精彩文章分享，欢迎持续关注。